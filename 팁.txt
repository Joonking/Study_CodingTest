
*** 자주 까먹는거 or 새로운 팁들 정리 ***

cin, cout 빠르게

	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);


배열 특정 값으로 채우기 fill

	전체 초기화 : 처음에는 [0][0]을 써주고, 그 다음 칸에는 [최대 행(값) - 1][최대 열], 다음 칸에는 초기 상태의 값
	ex>	fill(&map[0][0], &map[MAX - 1][MAX], 0);  
	ex> 	fill(&visited[0][0], &visited[MAX - 1][MAX], false);
	


큐 만들고, pair 만들어 넣기

	queue<pair<int, int>> Queue;
	Queue.push(make_pair(x, y));
	pair<int, int> now = Queue.front();
	Queue.pop();
	int nowX = now.first;
	int nowY = now.second;




공백 포함 문자열 입력받기
	1. getline 이용
	int main() {
		string s;
		getline(cin, s);
		cout << s;
	}
	getline을 쓰면 알아서 공백 포함하여 문자열을 입력받는다.

	2. cin.getline 이용
	int main() {	
		char s[100];
		cin.getline(s, 100, '\n');
		cout << s;
	}
	cin.getline(char배열 이름, 배열크기, 구분문자);
	다른점은 엔터말고 특정문자로 입력을 종료시킬 수 있다는 점

	3. gets_s 이용
	int main() {
		char s[100];
		gets_s(s, sizeof(s));
		cout << s;
	}
	2번이랑 비슷하다.
	gets_s(char배열 이름, 배열크기)


문자열 대소문자 관련
	소문자 판별 islower(str[i])		-> 소문자가 아니라면 0반환
	대문자 판별 isupper(str[i])		-> 대문자가 아니라면 0반환
	소문자 변환 str[i] = tolower(str[i])
	대문자 변환 str[i] = toupper(str[i])


cout 소수점 출력하기
	cout << fixed;
	cout.precision(3);    -> 0.342    소수점 3자리까지 출력
	cout.unsetf(ios::fixed)				-> 소수점 고정 해제




int, long, long long -> string
	long long sum;
	string an = to_string(sum);



string -> int, unint, long, float, double, long double
	stoi			int
	stoul			unsigned long
	stoull			unsigned long long
	stof			float
	stod			double
	stold			long double



유클리드 호제법 정의 (문제 2609_최대공약수와최소공배수)
	2개의 자연수  a, b에 대해서 a를 b로 나눈 나머지를 r이라 하면(단 a > b), 
	a와 b의 최대공약수는 b와 r의 최대공약수와 같다.
	이 성질에 따라, b를 r로 나눈 나머지 r0를 구하고, 
	다시 r을 r0로 나눈 나머지를 구하는 과정을 반복하여 나머지가 0이 되었을 때 
	나누는 수가 a와 b의 최대공약수이다.

	int gcd(int a, int b)			<- 최대 공약수 구하는 함수
	{
		if(a%b==0)return b;
		return gcd(b, a%b);
	}


Hash Table
	- 해쉬는 전화번호부와 같음.
	- 키값과 value 값으로 이루어져있음.

	c++ 에서 제공하는 map은 데이터를 정렬하여 저장한다.
	따라서 정렬이 필요 없을 경우에는 unordered_map 을 사용하는 것이 훨씬 성능이 좋다.
	데이터가 N개일때 탐색속도는
	map 의 경우 O(logN)
	unordered_map 의 경우 O(1) 가 된다.

	ex>
		map<key, value> name;
		unordered_map<key, value> name;
		//key, value에 int,string,bool등 자료형 넣음

		map에 원소 추가
		//name.insert(make_pair(key,value));
		//name[key] = 2;
		map<string, int> m;
		m.insert(make_pair("one",1));
		m["one"] = 1;

		map 원소에 접근
		name[key]
		name.at(key)

		map 키값으로 찾기
		name.find("one")
		키 값이 "one"인 원소의 iterator 리턴
		찾는 값이 없다면 name.end() 리턴


	
	sort 
		sort(arr.begin(), arr.end());		<- 기본 오름차순
		sort(arr.begin(), arr.end(), greater<자료형>());		<- 내림차순
		sort(arr.begin(), arr.end(), compare)		<- 사용자 정의 함수

		bool compare(int a, int b)			<- 사용자 정의 함수
		{
			return a > b;
		}



	이분탐색(이진탐색) - 술게임 업다운 게임
		이진탐색은 데이터가 정렬된 상태에서 원하는 값을 찾아내는 알고리즘임.
		찾고자 하는 값과 중앙값을 비교해서 탐색하는 범위를 절반씩 줄이면서 찾는 방식임.
		left				mid				right

		찾으려는 값 : 18
		left : 1					mid : 25						right : 50			-> 18 < 25 => right = mid -1

		left : 1					mid : 12						right : 24			-> 18 > 12 => left = mid +1

		left : 13					mid :	18						right :	24			-> 18 찾았당.

		만약 찾는 값이 없으면 break는 left > right 일때로 해주면 됨.
		while(left <= right) 로 설정하고 이진탐색






















